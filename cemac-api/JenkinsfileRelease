#!/usr/bin/env groovy

// Version du template Maven : 2.0.6
// Documentation : https://docs.apps.eul.sncf.fr/construire/templates/maven/

// D√©claration de la shared library build_libs
@Library('build_libs') _

// Options du build
Map options = [
    // Nombre de builds √† conserver dans l'historique des builds du job Jenkins
    NUM_TO_KEEP: 10,
    // Version de l'image maven utilis√©e pour le build
    MAVEN_VERSION: '3.9.6-eclipse-temurin-21',
    // D√©finir √† true si une image Docker applicative est √† produire
    DOCKER_BUILD: false,
    // D√©finir √† true pour des logs du build Docker plus d√©taill√©s
    IMAGE_BUILD_VERBOSE: false,
]

// Valorisation des options par d√©faut
options = defaultBuildOptions(options)

// Propri√©t√©s du job
properties([
    // Connexion GitLab
    gitLabConnection("${options['GITLAB_NAME']}"),
    // Conservation des N derni√®res ex√©cutions
    buildDiscarder(logRotator(numToKeepStr: "${options['NUM_TO_KEEP']}")),
    // Param√®tres du build de release. Les valeurs du build pr√©c√©dent sont prises comme valeurs par d√©faut
    parameters([
        string(name: 'BRANCH_RELEASE', defaultValue: "${params['BRANCH_RELEASE']}", description: 'nom de la branche √† releaser', trim: true),
        string(name: 'RELEASE_VERSION', defaultValue: "${params['RELEASE_VERSION']}", description: 'version de la release √† construire (format : X.Y.Z)', trim: true),
        string(name: 'DEVELOPMENT_VERSION', defaultValue: "${params['DEVELOPMENT_VERSION']}", description: 'prochaine version de d√©veloppement (format : X.Y.Z-SNAPSHOT)', trim: true),
        choice(name: 'REPO_DEPLOY_RELEASE', choices: ['prod', 'dev'], description: 'r√©pertoire de destination des artefacts de release sur Artifactory (dev ou prod)'),
    ]),
])

// Tous les param√®tres du build de release doivent √™tre renseign√©s
params.each { param ->
    if (!param.value) {
        error "‚ùå Le param√®tre ${param.key} doit √™tre renseign√©"
    }
}

// Cible 'dev' ou 'prod' de la release, qui d√©termine le d√©p√¥t Artifactory de publication
String targetRepositoryType = params.REPO_DEPLOY_RELEASE
Boolean targetingProd = targetRepositoryType == 'prod'
Boolean dockerEnabled = options['DOCKER_BUILD'] == true

// Le nom du build prend le nom de la version √† livrer
currentBuild.displayName = "${RELEASE_VERSION} - ${targetRepositoryType}"

// Sinon, s'il est activ√©, l'horodatage des logs du CLI eul est d√©cal√© d'une heure
env.TZ = 'Europe/Paris'

// Horodatage des lignes de log Jenkins
timestamps {
    ansiColor('xterm') {
        withTools([
            [name: 'maven', version: "${options['MAVEN_VERSION']}"],
            dockerEnabled ? [name: 'buildkit', image: 'moby/buildkit', version: 'rootless'] : [:],
        ]) {
            try {
                stage('Checkout') {
                    println 'üî∞ R√©cup√©ration du code source'
                    scmInfo = checkout scm
                    env.GIT_URL = scmInfo.GIT_URL
                    env.GIT_SHORT_URL = "${env.GIT_URL}".replace('https://', '')
                    env.GIT_COMMIT = scmInfo.GIT_COMMIT
                    println '‚úîÔ∏èÔ∏è R√©cup√©ration du code source effectu√©e'
                }
                stage('Setup') {
                    container('maven') {
                        println 'üî∞ Configuration du build'
                        // V√©rification de l'unicit√© du tag quand la cible de publication est le d√©p√¥t de production
                        if (RELEASE_VERSION == sh(script: 'git tag -l $RELEASE_VERSION', returnStdout: true).trim()) {
                            if (targetingProd) {
                                error "‚ùå Le tag ${RELEASE_VERSION} existe d√©j√†"
                            }
                            env.TAG_ALREADY_EXISTS = true
                            println "üìú Le tag $RELEASE_VERSION existe. Il sera remplac√© en fin de release"
                        } else {
                            env.TAG_ALREADY_EXISTS = false
                            println "üìú Le tag $RELEASE_VERSION n'existe pas. Il sera pos√© en fin de release"
                        }
                        sh 'git config --global user.email pic-eul@sncf.com'
                        sh 'git config --global user.name "PIC e.UL"'
                        if (env.TAG_ALREADY_EXISTS?.toBoolean()) {
                            // Suppression du tag existant
                            sh 'git tag -d $RELEASE_VERSION'
                        }
                        // Change la version des POMs en version de release (i.e sans -SNAPSHOT)
                        println 'üî∞ Mise √† jour de la version'
                        sh 'eul mvn versions:set -DnewVersion=$RELEASE_VERSION -DprocessAllModules -DgenerateBackupPoms=false'
                        // commit les POMs modifi√©s et taggue la release (utilisation de git pathspec)
                        sh '''
                            git add :/*pom.xml
                            git commit -m "release $RELEASE_VERSION"
                            git tag $RELEASE_VERSION
                        '''
                        println '‚úîÔ∏èÔ∏è Configuration du build effectu√©e'
                    }
                }
                stage('Build') {
                    container('maven') {
                        println 'üî∞ Build'
                        sh 'eul mvn compile -Dmaven.test.skip'
                        println '‚úîÔ∏è Build effectu√©'
                    }
                }
                stage('Tests') {
                    container('maven') {
                        println 'üî∞ Ex√©cution des tests unitaires'
                        if (sh(script: 'eul mvn org.jacoco:jacoco-maven-plugin:prepare-agent test org.jacoco:jacoco-maven-plugin:report', returnStatus: true)) {
                            error '‚ùå Release annul√©e. Les tests unitaires ont √©chou√©'
                        }
                        println '‚úîÔ∏è Ex√©cution des tests unitaires effectu√©e'
                    }
                }
                stage('Quality gate') {
                    container('maven') {
                        println 'üî∞ Analyse qualit√© avec barri√®re qualit√©'
                        withSonarQubeEnv('sonarqube') {
                            sh """\
                                eul mvn sonar:sonar \
                                    -DskipTests=true \
                                    -Dsonar.projectKey=${options['PROJECT_SONAR_KEY']} \
                                    -Dsonar.projectVersion=\${RELEASE_VERSION} \
                                    -Dsonar.links.ci=${JOB_URL} \
                                    -Dsonar.links.homepage=${GIT_URL}
                            """
                        }
                        // Contr√¥le du passage de la barri√®re qualit√©
                        timeout(time: 1, unit: 'HOURS') {
                            if (waitForQualityGate()?.status != 'OK') {
                                error "‚ùå Release annul√©e. Le projet n'a pas pass√© la barri√®re qualit√©"
                            }
                        }
                        println '‚úîÔ∏è Analyse qualit√© effectu√©e. Le projet a pass√© la barri√®re qualit√©'
                    }
                }
                stage('Local CVE scan') {
                    container('maven') {
                        println 'üî∞ Scan de s√©curit√© local sur les artefacts produits'
                        // Scan CVE d√©clench√© au plus t√¥t pour ne pas publier d'artefact avec vuln√©rabilit√©s critiques
                        if (sh(script: 'eul artefacts cve-scan --local --critical --mvn', returnStatus: true)) {
                            // La pr√©sence de CVE critiques dans les artefacts est bloquante
                            error "‚ùå Release annul√©e. Le scan de CVE a identifi√© des vuln√©rabilit√©s critiques dans l'artefact ou ses d√©pendances"
                        }
                        println '‚úîÔ∏èÔ∏è Scan CVE local effectu√©'
                    }
                }
                stage('Release') {
                    container('maven') {
                        println 'üî∞ Publication des artefacts'
                        // Publication des artefacts dans Artifactory
                        // Prise en compte du param√®tre du job par le CLI afin de pousser les binaires de release sur le d√©p√¥t maven_${ARESIS}_dev ou maven_${ARESIS}_prod
                        sh "eul --repo-target ${targetRepositoryType} mvn install -DskipTests=true"
                        // Publication des informations de build dans Artifactory
                        sh 'eul artefacts build-publish'
                        // Publication Jenkins du lien sur le build Artifactory
                        publishArtifactoryBuildLink()
                        println '‚úîÔ∏è Publication des artefacts effectu√©e'
                        // Mise √† jour de la version de d√©veloppement
                        sh 'eul mvn versions:set -DnewVersion=$DEVELOPMENT_VERSION -DprocessAllModules -DgenerateBackupPoms=false'
                        println "üî∞ Push des modifications avec publication du tag ${RELEASE_VERSION}"
                        // ‚ö†Ô∏è Dans le cas d'une release sur le d√©p√¥t de dev (non immutable), si le tag existe d√©j√† alors il est d√©plac√©,
                        // il faut dans ce cas utiliser l'option -f sur le push du tag
                        env.GIT_PUSH_TAG_OPTS = env.TAG_ALREADY_EXISTS?.toBoolean() ? '-f' : ''
                        // Commit les POMs modifi√©s
                        sh '''
                            git add :/*pom.xml
                            git commit -m "prepare the next snapshot version : $DEVELOPMENT_VERSION"
                            git push https://${gitlab_user}:${gitlab_pass}@$GIT_SHORT_URL $BRANCH_RELEASE
                            git push ${GIT_PUSH_TAG_OPTS} https://${gitlab_user}:${gitlab_pass}@$GIT_SHORT_URL refs/tags/$RELEASE_VERSION
                        '''
                    }
                    println "‚úîÔ∏èÔ∏è Release de ${RELEASE_VERSION} effectu√©e"
                }
                stage('CVE scan') {
                    container('maven') {
                        println 'üî∞ Scan de s√©curit√© distant sur les artefacts produits sur Artifactory'
                        // Par d√©faut, le scan de build est synchrone pour le pipeline de release. Le r√©sultat final du scan sera attendu par le pipeline.
                        // Pour forcer le pipeline √† ne pas attendre le r√©sultat du scan de build, il faut enlever le flag `--wait-for-result` √† la commande de scan cve.
                        // cf: https://docs.apps.eul.sncf.fr/share/securise-scan-dependances
                         if (sh(script: 'eul artefacts cve-scan --wait-for-result', returnStatus: true)) {
                            // Si le pipeline arrive √† ce stage cela veut dire qu'il a pass√© le scan local et ne pr√©sente pas de CVE critiques mais hautes.
                            // Pour mettre la pipeline en erreur, remplacer unstable "‚ö†Ô∏è..." par error "‚ùå..." dans la ligne suivante
                            unstable "‚ö†Ô∏èÔ∏è Le scan de CVE a identifi√© des vuln√©rabilit√©s hautes dans l'artefact ou ses d√©pendances"
                        }
                        println '‚úîÔ∏è Scan CVE distant effectu√©'
                    }
                }
                stage('Docker build') {
                    when(dockerEnabled) {
                        println 'üî∞ build Docker avec Buildkit'
                        String dockerVerboseOption = options['IMAGE_BUILD_VERBOSE'] ? '--debug' : ''
                        env.IMAGE_NAME = options['PROJECT_NAME']
                        env.IMAGE_VERSION = "${RELEASE_VERSION}"
                        container('buildkit') {
                            result = sh(script: "eul --repo-target ${targetRepositoryType} image $dockerVerboseOption build docker --tag=$IMAGE_NAME:$IMAGE_VERSION --build-arg 'VERSION=$IMAGE_VERSION'", returnStatus: true)
                            if (result != 0) {
                                error '‚ùå Le build Docker avec BuildKit a √©chou√©'
                            }
                        }
                        println '‚úîÔ∏è build Docker effectu√©'
                    }
                }

                stage('Docker CVE scan') {
                    when(dockerEnabled) {
                        container('buildkit') {
                            println 'üî∞ Scan CVE distant sur l\'image docker produite'
                            // Par d√©faut, le scan docker est synchrone pour le pipeline de release. Le r√©sultat final du scan sera attendu par le pipeline.
                            // Pour forcer le pipeline √† ne pas attendre le r√©sultat du scan docker, il faut enlever le flag `--wait-for-result` √† la commande de scan cve.
                            // cf: https://docs.apps.eul.sncf.fr/share/scan-conteneur
                            result = sh(script: "eul --repo-target ${targetRepositoryType} image scan $IMAGE_NAME:$IMAGE_VERSION --wait-for-result", returnStatus: true)
                            if (result > 0) {
                                if (result == 4) {
                                    // La pr√©sence de CVE critiques dans l'image docker n'est pas bloquante.
                                    // Pour mettre le pipeline en erreur, remplacer unstable "‚ö†Ô∏è..." par error "‚ùå..." dans la ligne suivante.
                                    unstable "‚ö†Ô∏è Le scan CVE distant Docker a identifi√© des vuln√©rabilit√©s critiques dans l'image produite"
                                } else {
                                    error '‚ùå Le Scan CVE distant Docker a √©chou√©'
                                }
                            }

                            println '‚úîÔ∏è Scan CVE distant sur l\'image docker produite effectu√©'
                        }
                    }
                }

                println 'üëç Build du job de release termin√© avec succ√®s'
                currentBuild.result = 'SUCCESS'
            } catch (all) {
                currentBuild.result = 'FAILURE'
                // Envoi d'un mail en cas d'√©chec
                emailext(
                    body: '$DEFAULT_CONTENT',
                    subject: '$DEFAULT_SUBJECT',
                    // Destinataires : auteurs d'une modification du code et d√©clencheur du pipeline
                    recipientProviders: [[$class: 'DevelopersRecipientProvider'], [$class: 'RequesterRecipientProvider']],
                    // Pour √©galement envoyer le mail √† une liste d'adresses (s√©par√©es par des ,) :
                    //to: "adressmail1, adressmail2"
                )
                throw all
            }
            finally {
                // Collecte et remont√©e dans Jenkins des probl√®mes rencontr√©s pendant le build, ainsi que les r√©sultats des tests unitaires.
                // Documentation : https://docs.apps.eul.sncf.fr/share/sharedlib-addngissuesreporttojob/
                addNgIssuesReportToJob(
                    'tools': [
                        'cveScan',
                        'maven',
                        'taskScanner',
                        ['junitPlugin': ['testResults': '**/target/surefire-reports/*.xml']],
                        ['junitParser': ['pattern': '**/target/surefire-reports/*.xml']],
                    ]
                )
                // Pour le suivi et les indicateurs eUL
                eulNotify()
            }
        }
    }
}
